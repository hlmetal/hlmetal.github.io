---
layout: post
title:  "分布式架构之浅谈"
date:   2019-04-01 09:00:30 +0200
categories: 分布式架构
---

分布式架构优缺点、技术栈以及分布式架构中的各种机制, 如容错、性能等设计思路

## 分布式架构
### 优点
* 增大系统容量，随着业务量增大，必须要多台机器才能应对，要将业务系统水平或垂直拆分； 大流量处理： 通过集群技术把大规模并发请求的负载分散到不同的机器上
* 加强系统可用性，随着业务越来越关键，就不能出现单点故障，要通过分布式架构冗余系统以消除单点故障；关键业务保护，把故障隔离起来阻止雪崩效应，如果流量过大，需要对业务降级，以保护关键业务流转
* 模块化，系统重用性高、扩展性高、耦合度低
* 服务拆分，开发和发布速度变快
* 团队协作得到改善

### 缺点
* 架构设计复杂、服务部署复杂
* 技术多元化，运维、测试、查错复杂度增加
* 服务治理和调度变得困难
* 系统响应时间变长
* 线上故障工单解决变慢，会在不同服务和团队中转来转去\

### 难点
* 异构系统的不标准问题， 例如：通信协议、数据格式不标准
* 系统架构中的服务依赖性问题，木桶短板效应
* 故障发生的概率更大
* 多层架构的运维复杂度更大，基础层、平台层、应用层和接入层，任何一层的问题都会导致整体的问题

### 技术栈
* 提高架构稳定性
    * 服务拆分
    * 服务冗余
    * 限流降级
    * 高可用架构、高可用运维
* 提高架构性能
    * 缓存系统
    * 负载均衡系统
    * 异步调用
    * 数据分区、数据镜像

### 关键技术
* 全栈系统监控
    * 基础层：监控主机和底层资源， 例如： CPU、内存、网络吞吐、硬盘 I/O
    * 中间层：中间件层的监控， 例如： Nginx、Redis、ActiveMQ、Kafka、MySQL、Tomcat
    * 应用层：监控应用层的使用， 例如： HTTP 访问的吞吐量、响应时间、返回码、调用链路分析
    * 标准化：日志数据结构化、监控数据格式标准化、统一的监控平台、统一的日志分析
    * 好的监控系统: 关注于整体应用的 SLA、关联指标聚合、快速故障定位
    * 怎么做: 服务调用链跟踪、服务调用时长分布、服务的 TOP N 视图、数据库操作关联、服务资源跟踪
* 服务 / 资源调度
    * 服务关键程度、服务依赖关系图
    * 服务状态和生命周期的管理：服务注册中心
    * 架构的版本管理
    * 资源 / 服务调度、服务状态的维持和拟合、服务的弹性伸缩和故障迁移
* 流量调度
    * 服务流控，服务发现、服务路由、服务降级、服务熔断、服务保护
    * 流量控制，负载均衡、流量分配、流量控制、灾备多活
    * 流量管理，协议转换、请求校验、数据缓存、数据计算
* 状态 / 数据调度
    * 应用层上的分布式事务一致性，只有两阶段提交这样的方式
    * 底层存储可以解决这个问题的方式是通过一些像 Paxos、Raft 或是 NWR
* 开发和运维的自动化

## 分布式架构之设计模式
### 容错设计
容错主要是为了可用性，系统可用性计算： MTTF/MTTF +MTTR（几个9） MTTF = 平均故障前的时间，即系统平均能够正常运行多长时间才发生一次故障 MTTR = 平均修复时间
* 故障隔离->系统分离：按服务种类分离/按用户分离（多租户）

#### 异步通讯
* 请求响应式
    * 发送方会直接请求接收方，被请求方接收到请求后，直接返回——收到请求，正在处理
    * 对于返回结果，一种是发送方时不时地轮询；另一种是发送方注册一个回调方法，接收方处理完后回调请求方
* 通过订阅的方式
    * 接收方订阅发送方的消息，发送方把相关的消息或数据放到接收方所订阅的队列中，接收方会从队列中获取数据
* 通过 Broker 的方式（最佳方式）
    * 发送方向 Broker 发送消息，接收方向 Broker 订阅消息，Broker就是个消息中间件

#### 幂等性
一个调用被发送多次所产生的副作用和被发送一次所产生的副作用是一样的
* 服务调用有三种结果：成功、失败和超时，其中超时是我们需要解决的问题
    * 下游系统提供相应的查询接口,上游系统在 timeout 后去查询一下
    * 查询操作交给下游, 上游只管重试，下游保证一次和多次的请求结果是一样的(幂等)
* 幂等需要有一个全局唯一的标识（Snowflake算法）

#### 补偿事务
保持一致性ACID/BASE
  <img src= "/assets/files/to_be_supplemented.png" alt="加载错误" title="有待补充"/>

#### 重试设计
* 判断什么情况下需要重试，例如，调用超时、被调用端返回了某种可以重试的错误; 业务级的错误（如没有权限、或是非法数据等错误），技术上的错误等就不必重试
* 需要有个重试的最大值，经过一段时间不断的重试后，就没必要再重试了，应该报故障
* 在重试过程中，每一次重试失败时都应该休息一会儿再重试，这样可以避免因为重试过快而导致网络上的负担加重

##### Spring Retry(通过配置 @Retryable 注解)
* 重试策略
    * NeverRetryPolicy，只允许调用1次RetryCallBack，不允许重试
    * AlwaysRetryPolicy，无限重试，直到成功
    * SimpleRetryPolicy，固定次数，默认3次
    * TimeoutRetryPolicy，超时重试，默认1s
    * CircuitBreakerRetryPolicy，熔断重试
* backoff策略
    * NoBackOffPolicy 无退避，立即重试
    * FixedBackOffPolicy 固定时间的退避策略
    * UniformRandomBackOffPolicy 随机时间
    * ExponentialBackOffPolicy 指数退避策略

#### 熔断设计
防止应用程序不断地尝试执行可能会失败的操作
* 状态
    * 闭合:失败计数器在调用失败是+1,当达到阈值就会断开;此时开启超时时钟,在超过该时间后切换到半断（给体系修正错误的机会）
    * 半断开:允许一定流量调用服务，调用成功则切换到闭合，调用失败则断开； 有效防止正在恢复中的系统被突然的大量请求拖垮
    * 断开:请求会直接返回错误，而不调用后端服务
* 设计重点
    * 错误的类型:什么时候需要重试，什么时候需要直接熔断
    * 日志监控:监控使用熔断器保护服务的执行情况
    * 测试服务是否可用:定期检查远程服务健康状态
    * 手动重置功能:可以手动地强制将熔断器切换到闭合或断开
    * 并发问题:最好使用无锁的数据结构或atomic的原子操作
    * 资源分区:只对有问题的分区熔断
* Netflix的Hystrix

#### 限流设计
对并发访问进行限速，一旦达到阈值，触发限流行为
##### 限流行为
* 拒绝服务:多出来的请求直接拒绝，可以防止一些不正常或恶意高并发访问
* 降级服务:关闭不重要服务，将cpu、内存等让渡给重要的功能； 或者不再返回全量数据，只返回部分数据
* 特权请求:资源让渡给大客户，保证大客户请求能够优先处理
* 延时处理:使用缓冲队列，队列满了拒绝服务，一般用于断在的峰刺请求
* 弹性伸缩:使用自动化运维的方式对相应服务进行伸缩

##### 实现方式
* 计数器:请求来时+1，请求处理完时-1，当计数器达到阈值就拒绝请求
* 队列算法:FIFO队列，优先级队列，带权重队列
* 漏斗算法:在队列中加一个限流器，以匀速处理请求
* 令牌桶算法:在桶内以一定速率放入token，处理请求时需要拿到token，才能处理； 流量小时攒token，流量大时可以快速处理
* 基于响应时间

##### 设计重点
* 为了向用户承诺 SLA\为了应对突发的流\节约成本
* 在架构的早期考虑、限流模块性能必须好、有个手动的开关、有个监控事件通知、返回特定的限流错误码、限流应该让后端的服务感知到

#### 降级设计
* 降低一致性:从强一致性变为最终一致性
    * 使用异步简化流程， 例如：订单系统，当订单量特别大，把在线支付降级为用户到付，从而快速结算订单
    * 降低数据一致性， 使用缓存或者直接去掉数据（不显示库存数量，只显示有无）
* 停止次要功能:限制流量->简化功能->停止功能
* 简化功能:返回全量数据切换为返回部分或最小可用数据
* 设计重点
    * 定义好降级的关键条件，做好相应的应急预案
    * 梳理业务功能，那些是必须死保的功能，那些事可以牺牲掉的功能

### 管理设计
#### 配置中心
##### 静态配置:软件启动时配置，运行时基本不变
##### 动态配置:运行时配置，例如： 日志级别、降级开关、活动开关等
* 分类
    * 按运行环境：开发环境、测试环境、预发环境、生产环境
    * 按依赖区分：是否有外部依赖配置（外部依赖配置放在服务发现系统中），例如： mysql链接配置
    * 按层次分：基础层（操作系统配置）、中间平台层（中间件配置）、软件层 （应用自身配置）

#### 部署升级策略
* 停机部署：例如在新版本中使用到了和老版本完全不兼容的数据表设计时就需要停机
* 蓝绿部署：在生产线上部署相同数量的新服务，然后当新的服务测试确认 OK 后，把流量切到新的服务这边来
* 滚动部署：逐个替换应用的所有实例
* 灰度部署：逐渐将生产环境流量从老版本切换到新版本 通常在对新版本质量缺乏信心或没有足够测试或缺少可靠测试时使用
* AB测试：同时上线两个版本，然后做相关的比较 用于测试应用功能表现（可用性、受欢迎程度等，例如：UI大改、推荐算法、流程等更改）

#### 网关模式
* 请求路由
* 服务注册， 注册 API 接口
* 安全方面， SSL 加密及证书管理、Session 验证、授权、数据校验
* 负载均衡
* 异步、重试、幂等、流控、熔断、监视
* API聚合、API编排

#### 边车模式
控制和逻辑的分离
  <img src= "/assets/files/to_be_supplemented.png" alt="加载错误" title="有待补充"/>

#### 分布式锁
* 特点:安全性、避免死锁、容错性
* Redis
* zookeeper
 <img src= "/assets/files/to_be_supplemented.png" alt="加载错误" title="有待补充"/>

### 性能设计
#### 缓存
##### 模式
* Cache Aside:先从cache取数据，取到则返回，没有则从DB取数据，成功后xi，将数据放入cache； 更新则是先存入DB，成功后，让缓存失效
* Read/Write Through
    * ReadThrough是在查询操作中更新缓存，当缓存失效时，由缓存服务自己加载，cache aside则是由调用方将数据载入缓存
    * WriteThrough是在更新数据时，没命中缓存则直接更新DB，命中缓存，则更新缓存，然后由缓存更新DB
* Write Behind Caching:更新数据的时候，只更新缓存，不更新数据库，缓存会异步地批量更新数据库

##### 设计重点
* 不能在 Service 内放 Local Cache、外部的缓存集群、数据分片、命中率、缓存时间周期、LRU 策略

#### 异步处理
事件驱动、事件溯源
 <img src= "/assets/files/to_be_supplemented.png" alt="加载错误" title="有待补充"/>

#### 数据库扩展
* 读写分离CQRS:Command(增、删、改)/Query(查)
* 分库分表
    * 分库策略: 地区、日期、范围、哈希散列算法
    * 分表策略: 用户ID、数据种类、范围

#### 秒杀
* 网关限流、过滤ip等
* CDN边缘节点计算，在CDN上部署个小服务，除了告诉前端请求开没开始外，还统计多少人在线，每隔段时间将数据回传给数据中心，当快开始的时候，数据中心向CDN上的小服务传递一个概率值，例如：100万人，0.02%概率，则200人抢，其他返回秒杀结束

#### 边缘计算
处理实时响应业务、简单业务、收集并结构化数据等