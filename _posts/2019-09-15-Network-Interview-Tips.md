---
layout: post
title:  "网络相关知识盘点"
date:   2019-09-15 09:00:30 +0200
categories: http
---

计算机网络相关知识点, 包括HTTP协议、TCP协议的实现、ARP流程等

## Http常用状态码及含义
* 1XX, 信息性状态码, 如`101,切换请求协议`
* 2XX, 成功状态码, 如`200,请求成功`
* 3XX, 重定向状态码, 如`301, 永久重定向; 302, 临时重定向`
* 4XX, 客户端错误状态码, 如`400, 客户端请求语法错误; 403, 服务器禁止访问(权限); 404, 服务器无法根据客户端请求找到资源`
* 5XX, 服务端错误状态码, 如`500, 服务端错误`

## Http常用请求方式
1. GET, 获取服务器资源的简单请求
2. POST, 发送包含用户提交数据的请求
3. PUT, 向服务器提交修改数据
4. DELETE, 删除服务器上资源
5. HEAD, 请求页面头部信息
6. CONNECT, 用于ssl隧道的基于代理的请求
7. OPTIONS, 返回可用方法, 常用于跨域
8. TRACE, 追踪请求/响应的传输路径

## Http请求头
1. Cache-Control:  HTTP1.1的头字段, 用来区分对缓存机制的支持情况, 请求头和响应头都支持这个属性. 通过它提供的不同的值来定义缓存策略. 主要有public、private、no-cache等值
2. expires:  过期时间(HTTP1.0的头字段), 如果设置了时间,则浏览器会在设置的时间内直接读取缓存,不再请求

## 端口及服务
1. 21——FTP文件传输协议
2. 22——SSH
3. 23——Telnet服务
4. 25——SMTP邮件传输协议
5. 53——DNS域名服务器
6. 80——HTTP超文本传输协议
7. 110——POP3邮件协议3
8. 443——HTTPS
9. 1080——Sockets
10. 1521——Oracle默认端口
11. 3306——Mysql默认端口
12. 6379——Redis默认端口
13. 2181——zookeeper默认端口
14. 27017——mongodb默认端口
15. 15672——rabbitmq默认端口

## 计算机网络体系结构
### OSI参考模型
1. 物理层: 建立、维护、断开物理连接
2. 数据链路层: 在物理层提供比特流服务的基础上, 建立相邻节点之间的数据链路
3. 网络层: 进行逻辑地址寻址, 实现不同网络间的路径选择, 协议有ICMP、IGMP、IP等
4. 传输层: 定义传输数据的协议端口号, 流控、差错校验等, 协议有TCP、UDP
5. 会话层: 建立、管理、终止会话, 对应主机进程
6. 表示层: 数据的表示、安全、压缩,确保一个系统应用层发送的消息可以被另一个系统的应用层读取
7. 应用层: 网络服务与最终用户的一个接口, 常见协议: HTTP/FTP/SMTP/SNMP/DNS

### TCP/IP体系结构
1. 网络接口层: 对应OSI的数据链路层、物理层
2. 网际层: 对应OSI的网络层, 主要解决主机到主机的通信问题
3. 传输层: 对应OSI的传输层,为应用层实体提供端到端的通信功能,保证了数据包的顺序传送及数据的完整性
4. 应用层: 对应OSI的应用层、表示层、会话层

### 五层协议体系结构
1. 物理层: HUB/网线/中继器
2. 数据链路层: ARQ自动重传请求协议/CSMA/CD停止等待协议/PPP点对点协议
3. 网络层: IP网际协议/ARP地址转换协议/RARP反向地址转换协议/ICMPInternet控制报文协议/IGMPInternet组管理协议/RIP路由信息协议/OSPF分布式链路状态协议/BGP边界网关协议
4. 传输层: TCP传输控制协议/UDP用户数据报文协议
5. 应用层: HTTP超文本传输协议/FTP文本传输协议/SMTP简单邮件传输协议/DNS域名系统/SSH安全外壳协议/DHCP动态主机配置协议/TELNET远程登录协议

## TCP协议
可靠的，基于字节流的，面向连接的传输层双工协议
### 特征
1. 通信双方的数据传输是稳定的,即便是在网络不好的情况下,也能够保证数据传输到目标端
2. TCP通信双方的数据包传输是通过字节流来实现传输的
3. 数据传输之前,必须要建立一个连接,然后基于这个连接进行数据传输

### 网络四元组
一个服务端端可以接收多个客户端的连接. 当多个客户端连接到服务端的时候,服务端需要去识别每一个连接, 并且TCP是全双工协议, 数据允许在连接的两个方向上同时传输(客户端如果是反向通信就变成了服务端). 通过**源IP地址、目标IP地址、源端口号、目标端口号**来确定一个唯一的TCP连接


### 三次握手
三次握手即通信双方一共需要发送三次请求,才能确保这个连接建立
客户端有SYN_SEND、ESTABLISHED状态,服务端有SYN_RCVD、ESTABLISHED状态
  <img src= "/assets/files/TCP三次握手.jpg" alt="加载错误" title="TCP三次握手"/>

1. 客户端向服务端发送连接请求并携带同步序列号SYN
2. 服务端收到请求后,发送SYN和ACK(ACK表示对前面收到请求的一个确认)
3. 客户端收到服务端的请求后,再次发送ACK

### 为什么要三次握手
1. TCP是可靠性通信协议,所以TCP协议的通信双方都必须要维护一个序列号, 去标记已经发送出去的
数据包, 哪些是已经被对方签收的. 而三次握手就是通信双方相互告知序列号的起始值, 为了确保这
个序列号被收到，所以双方都需要有一个确认的操作
2. TCP协议需要在一个不可靠的网络环境下实现可靠的数据传输，意味着通信双方必须要通过某种手段
来实现一个可靠的数据传输通道，而三次通信是建立这样一个通道的最小值。当然还可以四次、五次，
只是没必要浪费这个资源。
3. 防止历史的重复连接初始化造成的混乱问题，比如说在网络比较差的情况下，客户端连续多次发送建
立连接的请求，假设只有两次握手，那么服务端只能选择接受或者拒绝这个连接请求，但是服务端不
知道这次请求是不是之前因为网络堵塞而过期的请求，也就是说服务端不知道当前客户端的连接是有
效还是无效。

### 四次挥手
  <img src= "/assets/files/TCP四次挥手.jpg" alt="加载错误" title="TCP四次挥手"/>

1. 客户端发送关闭连接请求后进入FIN_WAIT1
2. 服务端收到后响应ACK, 并进入关闭等待, 客户端收到ACK后进入FIN_WAIT2
3. 服务端发送关闭连接请求后进入LAST_ACK
4. 客户端收到关闭连接请求后响应ACK, 并进入TIME_WAIT, 服务端收到ACK后进入CLOSED状态, 客户端等待固定时间后没收到服务端的ACK即认为服务端已关闭连接, 客户端也关闭连接, 进入CLOSED状态

### 为什么要四次挥手

### 为什么要TIME_WAIT状态是等待2MSL
1. 保证四次挥手中主动关闭方最后的ACK报文能最终到达对端
2. 保证对端没有收到ACK, 那么进行重传的 FIN报文能够到达

### TCP如何保证可靠性
1. 三次握手、四次挥手保证建立和断开连接的可靠性
2. 有状态, 记录哪些数据发送了、哪些数据接收了, 以及保证数据包按序到达
3. 可控制, 数据包校验、ACK 应答、超时重传、失序数据重传、丢弃重复数据、流量控制、拥塞控制等机制

### TCP重传机制
#### 超时重传
在客户端发送数据报文时, 设置一个定时器, 每间隔一段时间没有收到服务端的ACK应答报文, 就重发
* 间隔时间RTO 略大于 RTT(数据包从发出到响应回来的时间, 即一次往返时间)
* 缺陷: 增加了端到端的时延; 可能引起不必要的重传

#### 快速重传
客户端发送数据报文, 服务端接收, 若客户端连着收到3个重复的ACK确认消息, 则表示某数据报文丢失, 随即重传
* 缺陷: 客户端不知道具体哪个数据报文丢失, 需要重传多少个包

#### 带选择确认的重传(SACK)
基于快速重传, 服务端还会返回最近收到的报文段序列号范围, 客户端收到后就知道哪些数据包需要重传

#### 重复SACK
基于SACK扩展, 告诉客户端哪些数据重复接收了

### TCP滑动窗口
窗口是在操作系统开辟的一个缓存空间, 窗口大小表示无需等待应答即可继续发送数据的最大值. 包括发送窗口和接收窗口, 分别告诉对方还能容纳多少字节数据, 这样可以达到流量控制目的
1. 发送窗口
  <img src= "/assets/files/TCP发送窗口.jpg" alt="加载错误" title="TCP发送窗口"/>
* SND.WND: 发送窗口大小
* SND.NXT: 下一个发送位置
* SND.UNA: 已发送但未确认的第一个字节序列号
2. 接收窗口
  <img src= "/assets/files/TCP接收窗口.jpg" alt="加载错误" title="TCP接收窗口"/>
* REV.WND: 接收窗口大小
* REV.NXT: 下一个接收位置

### TCP流量控制
发送方发送数据直到接收窗口变为0, 发送方停止发送, 开启一个定时任务,每隔一段时间,发送试探报文去询问接受方, 直到窗口大于0，才继续开始发送
### TCP拥塞控制
发送方维护一个拥塞窗口变量, 用来估算在一段时间内链路可以承载和运输的数据量, 变量大小表示网络拥塞程度,可以动态变化.
#### 慢启动
TCP连接建立完成后,一开始不要发送大量数据,而是先探测一下网络拥塞程度.由小到大逐渐增加拥塞窗口大小
1. 如果没有出现丢包,每收到一个ACK,就将拥塞窗口cwnd大小就加1MSS.每轮次(RTT)cwnd增加一倍,呈指数增长.
2. 如果出现丢包,拥塞窗口就减半,进入拥塞避免阶段
* 为了防止cwnd增长过大引起网络拥塞,还需设置一个慢启动阀值ssthresh, 当cwnd > ssthresh就进入拥塞避免

  <img src= "/assets/files/TCP拥塞控制-慢启动算法.jpg" alt="加载错误" title="TCP拥塞控制-慢启动算法"/>

#### 拥塞避免
cwnd到达慢启动阀值后, 每收到一个ACK, cwnd = cwnd + 1 / cwnd, 每过一个RTT, cwnd = cwnd + 1
  <img src= "/assets/files/TCP拥塞控制-拥塞避免算法.jpg" alt="加载错误" title="TCP拥塞控制-拥塞避免算法"/>

#### 拥塞发生
当网络拥塞发生丢包, 要么超时重传, 要么快速重传
1. 如果发生超时重传
* ssthresh = cwnd / 2
* cwnd = 1
* 进入新的慢启动过程
2. 如果发生快速重传
* ssthresh = cwnd
* cwnd = cwnd / 2
* 进入快速恢复算法

#### 快速恢复
快速恢复算法认为，还有3个重复ACK收到, 说明网络也没那么糟糕. 它与快速恢复一般同时使用, 在进入快速恢复之前ssthresh, cwnd都在上一步被更新, 此时快速恢复如下:
1. cwnd = sshthresh + 3
2. 重传丢失的那几个数据包
3. 如果再收到重复ACK, cwnd = cwnd + 1
4. 如果收到新数据的ACK, 表明恢复过程已经结束. 直到cwnd > ssthresh就再次进入拥塞避免

### TCP半连接和全连接
1. TCP三次握手时,客户端发送SYN到服务端,服务端收到后回复ACK和SYN,状态由LISTEN变为SYN_RCVD,此时这个连就被推入了SYN队列, 即半连接队
2. 当客户端回复ACK, 服务端接收后, 三次握手完成, 这时连接会等待被具体应用取走, 在被取走之前, 它被推入ACCEPT队列, 即全连接队列
3. SYN Flood
**(1)** 在短时间内,伪造不存在的IP地址,向服务器大量发起SYN报文,当服务器回复SYN+ACK报文后,不会收到客户端的ACK回应报文, 服务器上建立大量半连接, 致使半连接队列满了, 这就无法处理正常TCP请求
**(2)** 解决办法
* syn cookie: 在收到SYN包后,服务器根据一定方法,以数据包源地址、端口等信息为参数计算出一个cookie值作为自己✁SYNACK包序列号,回复SYN+ACK后,服务器并不立即分配资源进行处理,等收到发送方ACK包后,重新根据数据包源地址、端口计算该包中确认序列号是否正确, 如果正确则建立连接, 否则丢弃该包
* SYN Proxy防火墙: 服务器防火墙会对收到每一个SYN报文进行代理和回应,并保持半连接. 等发送方将ACK包返回后,再重新构造SYN包发到服务器, 建立真正的TCP连接

### TCP粘包和拆包
一个完整数据包可能会被TCP拆分成多个包进行发送,也可能把多个小数据包封装成一个大数据包发送, 即粘包拆包
  <img src= "/assets/files/TCP粘包和拆包.jpg" alt="加载错误" title="TCP粘包和拆包"/>

* 发送数据小于TCP发送缓冲区大小, TCP将多次写入缓冲区的数据一次发送出去,将会发生粘包
* 接收方没有及时接收缓冲区中数据，将发生粘包
* 发送数据大于TCP发送缓冲区剩余空间大小, 将会发生拆包
* 待发送数据大于MSS(最大报文长度), TCP在传输前将进行拆包. 即TCP报文长度-TCP头部长度 > MSS

### Nagle算法与延迟确认
一般情况下, Nagle算法和延迟确认不能一起使用. 一个延迟发一个延迟收就会造成更大延迟,会产生性能问题
#### Nagle算法
1. 作用: TCP/IP协议中,无论发送多少数据,总要在数据前面加上协议头.同时,对方接收到数据也需要发送ACK表示确认.为了尽可能利用网络带宽, TCP总希望尽可能发送足够大的数据. Nagle算法就为了尽可能发送大块数据, 避免网络中充斥着许多小数据块
2. 基本定义: 任意时刻,最多只能有一个未被确认小段.
* 小段: 小于MSS尺寸的数据块
* 未被确认: 一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到
3. 具体规则
* 如果包长度达到MSS, 则允许发送
* 如果该包含有FIN, 则允许发送
* 设置了TCP_NODELAY选项, 则允许发送
* 未设置TCP_CORK选项时, 若所有发出去的小数据包(包长度小于MSS)均被确认, 则允许发送
* 上述条件都未满足, 但发生了超时(一般为200ms), 则立即发送

#### 延迟确认
接收方收到数据包后, 如果暂时没有数据要发给对端,等一段时再确认. 如果这段时间刚好有数据要传给对端,ACK 就随着数据传输,而不需要单独发送一次ACK; 如果超过时间还没有数据要发送, 也发送ACK,避免对端以为丢包

## IP地址有哪些
IP地址 = 网络号 + 主机号
* A类地址(1~126): 以 0 开头, 网络号占前 8 位, 主机号占后面 24 位
* B类地址(128~191): 以 10 开头, 网络号占前 16 位, 主机号占后面 16 位
* C类地址(192~223): 以 110 开头, 网络号占前 24 位, 主机号占后面 8 位
* D类地址(224~239): 以 1110 开头, 保留位, 组播地址
* E类地址(240~255): 以 11110 开头, 保留位, 将来使用

  <img src= "/assets/files/IP地址分类.jpg" alt="加载错误" title="IP地址分类"/>

## ARP协议工作过程
Address Resolution Protocol(地址解析协议), 用于实现IP地址到MAC地址的映射
  <img src= "/assets/files/ARP协议.jpg" alt="加载错误" title="ARP协议"/>

1. 首先, 每台主机都会在自己的ARP缓冲区中建立一个ARP列表,以表示IP地址和MAC地址的对应关系
2. 当源主机需要将一个数据包要发送到目的主机时,会首先检查自己的ARP列表是否存在该IP地址对应的MAC地址
* 如果有, 就直接将数据包发送到这个MAC地址
* 如果没有, 就向本地网段发起一个ARP请求的广播包, 查询此目的主机对应的MAC地址. 此ARP请求的数据包
里包括源主机IP地址、硬件地址、以及目的主机IP地址
3. 网络中所有主机收到这个ARP请求后, 会检查数据包中目的IP是否和自己的IP地址一致
* 如果不相同, 就会忽略此数据包
* 如果相同, 该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表, 如果ARP表中已经存在该IP信息, 则将其覆盖,然后给源主机发送一个ARP响应数据包, 告诉对方自己是它需要查找MAC地址
4. 源主机收到这个ARP响应数据包后, 将得到的目的主机IP地址和MAC地址添加到自己的ARP列表, 并利用此信息开始数据传输. 如果源主机一直没有收到ARP响应数据包, 表示ARP查询失败

## 有IP地址, 为什么需要MAC地址
1. 标识网络中一台计算机, 比较常用的就是IP地址和MAC地址, 但计算机IP地址可由用户自行更改, 而MAC地址不
可更改, 所以一般会把IP地址和MAC地址组合起来使用
2. IP地址和地域相关,对于同一个子网上设备,IP地址前缀一样, 这样路由器通过IP地址前缀就知道设备在在哪个子网上, 若只用MAC地址, 路由器则需要记住每个MAC地址在哪个子网,这需要路由器有极大存储空间, 这无法实现
3. MAC地址比作收件人, IP地址比作Address, 要通信两个就缺一不可

## TCP和UDP常见的应用层协议
### 基于TCP的应用层协议
1. HTTP: 超文本传输协议, 默认端口 80
2. FTP: 文件传输协议, 默认端口 20 用于传输数据, 21 用于传输控制信息
3. SMTP: 简单邮件传输协议, 默认端口 25
4. TELNET: 网络电传, 默认端口 23
5. SSH: 安全外壳协议, 默认端口 2

### 基于UDP的应用层协议
1. DNS : 域名服务, 默认端口 53
2. TFTP: 简单文件传输协议, 默认端口 69
3. SNMP: 简单网络管理协议, 通过UDP端口 161 接收, 只有Trap信息采用UDP端口 162

### TCP与UDP区别


## 保活计时器(keepalive timer)
1. 客户端与服务器建立TCP连接后, 客户端突然发生故障. 服务器以后就不能再收到客户端发来的数据. 因此, 应当有措施使服务器不要再白白等待下去, 这就需要使用保活计时器
2. 具体实现:
* 服务器每收到一次客户端数据, 就重新设置保活计时器, 通常为两个小时
* 若两个小时都没有收到客户端数据, 服务端就发送一个探测报文段, 以后则每隔 75 秒钟发送一次
* 若连续发送 10 个探测报文段后仍然无客户端响应, 服务端就认为客户端出了故障, 接着关闭这个连接

## URI与URL区别
1. URI(Uniform Resource Identifier): 统一资源标志符, 主要作用是唯一标识一个资源
2. URL(Uniform Resource Location): 统一资源定位符, 主要作用是提供资源路径

## Session与Cookie区别
### Cookie
客户端浏览器用来保存服务端数据的一种机制. 当通过浏览器进行网页访问的时候, 服务器可以把某一些状态数据以key-value的方式写入到Cookie里面存储到客户端浏览器. 当客户端下一次再访问服务器的时候, 就可以携带这些状态数据发送到服务端, 服务端可以根据Cookie里面携带的内容来识别使用者
### Session
表示一个会话, 属于服务器端的容器对象, 默认情况下，针对每一个浏览器的请求, Servlet容器都会分配一个Session. Session本质上是一个ConcurrentHashMap, 可以存储当前会话产生的一些状态数据.
### 状态保存
Http协议本身是一个无状态协议. 基于服务端的session存储机制, 再结合客户端的Cookie机制, 就可以实现有状态的Http协议
1. 客户端第一次访问服务端的时候, 服务端会针对这次请求创建一个会话, 并生成一个唯一的sessionId来标注这个会话
2. 服务端把这个sessionid写入到客户端浏览器的cookie里, 用来实现客户端状态的保存
3. 后续的请求, 每次都会携带sessionid. 服务器端就可以根据这个sessionid来识别当前的会话状态

<head>
	<meta charset="utf-8"> 
	<link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css">  
	<script src="https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"></script>
	<script src="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>
</head>
<body>
<table class="table table-bordered table-striped">
	<caption>Session与Cookie</caption>
	<thead>
		<tr>
            <th>对比项</th>
			<th>Session</th>
			<th>Cookie</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>存放位置</td>
			<td>服务器</td>
			<td>客户端</td>
		</tr>
        <tr>
			<td>存储数据类型</td>
			<td>任意</td>
			<td>ASCII</td>
		</tr>
		<tr>
			<td>安全性</td>
			<td>较高</td>
			<td>较低</td>
		</tr>
        <tr>
			<td>存储空间大小</td>
			<td>大</td>
			<td>小</td>
		</tr>
		<tr>
			<td>有效期</td>
			<td>较短, 超时或客户端关闭都会失效</td>
			<td>可设置长时间保存</td>
		</tr>
	</tbody>
</table>

## Http协议的无状态

## HTTP请求流程(从浏览器输入url到显示页面的过程)
1. DNS解析查找域名对应的ip地址
2. 与服务器三次握手建立TCP连接
3. 向服务器发送HTTP请求
4. 服务器响应请求,返回页面内容
5. 浏览器解析渲染页面
6. 服务器TCP四次挥手关闭TCP链接

## HTTP1.0, 1.1, 2.0区别
### HTTP1.0
1. 默认使用短链接
2. 每次请求都要建立一个TCP连接

### HTTP1.1
1. 引入持久连接, TCP默认不关闭, 可以复用
2. 分块传输编码, 服务端每产生一块数据就发送一块. 用流模式取代缓存模式
3. 管道机制, 在同一个TCP连接中, 客户端可以同时发送多个请求

### HTTP2.0
1. 二进制协议, 头信息和数据体都是二进制
2. 完全多路复用
3. 报头压缩, 引入头信息压缩机制,使用gzip或compress压缩后再发送
4. 服务端推送, 运行服务器未经请求, 主动向客户端发送资源

## HTTP长连接及超时设置
1. 设置`connection=keep-alive`即可开启长连接, 在HTTP1.1后, 默认开启长连接
2. 设置超时
* httpd守护进程里可以设置keep-alive timeout
* header里也可以设置
3. keep-alive的三个参数
* tcp_keepalive_time=1800, 空闲多久后发送侦测包
* tcp_keepalive_intvl=15, 未收到响应ACK, 每隔多久发送一次侦测包
* tcp_keepalive_probes=5, 直到发送了多少次侦测包, 就丢弃该链接

## HTTP与HTTPS区别
* HTTP的请求信息是明文传输, 容易被窃取,且没有验证身份和数据完整性
* HTTPS是为了解决上述问题而生, HTTPS = HTTP + SSL/TLS
<head>
	<meta charset="utf-8"> 
	<link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css">  
	<script src="https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"></script>
	<script src="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>
</head>
<body>
<table class="table table-bordered table-striped">
	<caption>HTTP与HTTPS</caption>
	<thead>
		<tr>
            <th>对比项</th>
			<th>HTTP</th>
			<th>HTTPS</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>安全性</td>
			<td>不安全a</td>
			<td>安全</td>
		</tr>
        <tr>
			<td>默认端口</td>
			<td>80</td>
			<td>443</td>
		</tr>
		<tr>
			<td>资源消耗</td>
			<td>较小</td>
			<td>较大</td>
		</tr>
        <tr>
			<td>证书</td>
			<td>不需要</td>
			<td>需要</td>
		</tr>
		<tr>
			<td>报文加密</td>
			<td>明文</td>
			<td>密文</td>
		</tr>
	</tbody>
</table>

## HTTPS流程
  <img src= "/assets/files/HTTPS原理.jpg" alt="加载错误" title="HTTPS原理"/>

1. 客户端发起Https请求，连到服务器443端口
2. 服务器有一套数字证书(证书内容有公钥、证书颁发机构、失效日期等)
3. 服务器将自己的数字证书发送给客户端(包括公钥)
4. 客户端收到数字证书之后,验证证书合法性.如果证书验证通过,就会生成一个随机的对称密钥,用证书的公钥加密
5. 客户端将加密后的密钥发送到服务器
6. 服务器收到客户端发来的密文密钥之后,用自己之前保留私钥进行非对称解密,解密后得到客户端密钥,然后用客户端密钥对返回数据进行对称加密
7. 服务器将加密后密文返回到客户端
8. 客户端收到后,用自己的密钥对其进行对称解密,得到服务器返回的数据

## 数字证书与数字签名
1. 数字证书的构成: 公钥、个人等信息、数字签名
2. 公钥和个人等信息 -> 经过Hash摘要算法加密,形成摘要信息 -> CA用其私钥对信息摘要加密,形成数字签名

## 对称加密与非对称加密
* 对称加密: 加密解密用同一密钥, 常见算法DES、AES、RC5、RC6
* 非对称加密: 用一对公钥和私钥进行加密解密, 常见算法RSA、Elgamal、DSA、D-H、ECC

## DNS解析过程
1. 检查浏览器缓存,看否能找到域名对应IP地址, 找到就直接返回,否则进行下一步
2. 检查本地DNS服务器缓存, 如果查找到也直接返回,否则继续进行下一步
3. 向根域名服务器发送请求,根域名服务器返回负责顶级域名服务器IP地址列表
4. 向顶级域名服务器发送请求,返回负责权限域名服务器IP地址列表
5. 向权限域名服务器发送请求,返回域名对应的IP地址

## 常见网络攻击
### CSRF
1. 跨站请求伪造, 挟制用户在当前已登录Web应用上执行非本意操作
2. 可以检查Referer字段或添加检验token

### DoS、DDoS、DRDoS
1. DOS即拒绝服务, 如网络带宽攻击、连通性攻击
2. DDOS即分布式拒绝服务, 如SYN Flood, Ping of Death, ACK Flood, UDP Flood
3. DRDOPS即分布式反射拒绝服务

### XSS攻击
1. 跨站脚本攻击, 在目标网站中插入恶意html代码
2. 类型
* 存储型
* 反射型
* DOM型
3. 解决
* HTML转义
* 链接校验, 禁止以script开头的非法链接
* 输入校验, 限制输入长度等

### SQL注入


## OAuth
关于授权(Authorization)的开放技术标准. 本质上是一种协议,可以在不共享用户用户名和密码的前提下,实现将授权从应用程序另一个应用程序. 如在登录购物平台时不需要注册而是从微信来登录
### 工作原理
任何的身份认证, 本质上都是基于对请求方的不信任产生的. 而OAuth主要是解决多个应用之间的授权信任问题
1. 资源所有者(Resource Owner): 一般是指自己
2. 客户端(Client): 一般是指需要授权的应用, 比如京东APP
3. 资源服务器(Resource Server): 一般是指保存信息的服务器, 比如微信密码的服务器
4. 授权服务器(Authorization Server): 一般是指提供API的服务器. 比如微信的Open API服务

#### 流程
1. 客户端向资源拥有者发送授权请求, 一般资源拥有者的资源会存放在资源服务器
2. 客户端会收到资源服务器的授权许可
3. 客户端拿到许可之后再向授权服务器发送一次验证, 给客户端颁发一个Access Token访问令牌
4. 客户端拿到令牌之后, 交给资源服务器
5. 资源服务器会将获取到的令牌传给认证服务器验证令牌的有效性
6. 资源服务器验证令牌通过之后, 就会返回一个受保护的资源

#### 授权模式
1. 授权码模式
2. 简化模式
3. 密码模式
4. 客户端模式