---
layout: post
title: Dubbo基础
date:   2019-03-15 15:25:35 +0200
category: java rpc distributed
---

简单了解Dubbo

## Dubbo简介
Dubbo是一款高性能、轻量级的开源RPC框架. 它提供了分布式架构下的服务之间通信方案,使得开发者可以不需要关心网络通信的细节. 通过该框架可以使得远程服务调用方式和本地服务调用方式一样简单

### RPC框架
它是一种通过网络从远程计算机程序上获取服务, 而不需要了解代码网络技术实现的一种协议. 凡是符合这种协议的框架都可以称之为RPC框架. 例如: A计算机提供一个服务, B计算机可以像调用本地服务一样去调用A计算机提供的服务, 这就是RPC的主要作用
#### RPC协议
一个完整的RPC协议包含了四个组件, Client、Server、Client Stub和Sever Stub
1. Client表示服务的调用方, Sever表示服务提供方
2. Client Stub表示客户端存根, 专门用来存放服务端的地址信息, 将客户端的请求参数打包成网络消息(序列化), 然后通过网络远程发送给服务提供方
3. Server Stub表示服务端存根, 用来接收客户端发送过来的消息, 然后解析消息内容(反序列化), 并调用本地方法

#### 应用场景
1. 分布式系统网络通讯
2. 分布式子系统之间的服务治理
3. 分布式负载均衡和流控
4. 服务发现与注册
5. 构建分布式调试环境

#### 主流开源框架
Goole的gRPC、Facebook的Thrift、Alibaba的Dubbo
 
### 十层模式
Dubbo由10层模式构成,整个分层依赖由上至下
 <img src= "/assets/files/Dubbo十层模式.jpg" alt="加载错误" title="Dubbo十层模式"/>

1. 第一层的Business业务逻辑层由自己来提供接口和实现还有一些配置信息
2. 第二层的RPC调用的核心层负责封装和实现整个RPC的调用过程、负载均衡、集群容错、代理等核心功能
3. 第三次的Remoting则是对网络传输协议和数据转换的封装

### 核心能力
1. 面向接口代理的高性能RPC调用
2. 智能容错和负载均衡
3. 服务自动注册和发现
4. 高度可扩展能力
5. 运行期流量调度
6. 可视化服务治理和运维

### Dubbo工作原理
1. 服务启动的时候, provider和consumer根据配置信息, 连接到注册中心register, 分别向注册中心注册和订阅服务
2. register根据服务订阅关系, 返回provider信息到consumer, 同时consumer会把provider信息缓存到本地如果信息有变更, consumer会收到来自register的推送
3. consumer生成代理对象, 同时根据负载均衡策略, 选择一台provider, 同时定时向monitor记录接口的调用次数和时间信息
4. 拿到代理对象之后, consumer通过代理对象发起接口调用
5. provider收到请求后对数据进行反序列化, 然后通过代理调用具体的接口实现

### Dubbo负载均衡策略
#### 加权随机
1. 假设有一组服务器A, B, C. 对应的权重(weights)为5, 3, 2, 权重总和为10. 
2. 现在把这些权重值平铺在一维坐标值上, [0, 5)区间属于服务器A; [5, 8)区间属于服务器B; [8, 10)区间属于服务器C
3. 接下来通过随机数生成器生成一个范围在[0, 10)之间的随机数,然后计算这个随机数会落到哪个区间就可以了

#### 最小活跃数
1. 每个服务提供者对应一个活跃数active, 初始情况下所有服务提供者活跃数均为0.
2. 每收到一个请求, 活跃数加1, 完成请求后则将活跃数减1
3. 在服务运行一段时间后, 性能好的服务提供者处理请求的速度更快, 因此活跃数下降的也越快, 此
时这样的服务提供者能够优先获取到新的服务请求

#### 一致性hash
1. 通过hash算法,把provider的invoke和随机节点生成hash
2. 将这个hash投射到[0, 2^32 - 1]的圆环上, 查询的时候根据key进行md5, 然后进行hash, 得到第一个节点的值大于等于当前hash的invoker

#### 加权轮询
1. 假设服务器A、B、C 权重比为5:2:1
2. 那么在8次请求中,服务器A将收到其中的5次请求,服务器B会收到其中的2次请求,服务器C则收到其中的1次请求

#### 最短响应时间权重随机
计算目标服务的请求的响应时间, 根据响应时间最短的服务,配置更高的权重进行随机访问

### Dubbo如何动态感知服务下线
#### 服务注册和发现
Dubbo默认采用Zookeeper实现服务的注册与服务发现. 
1. 在Zookeeper上, 会采用树形结构的方式来维护Dubbo服务提供端的协议地址
2. Dubbo服务消费端会从Zookeeper Server上去查找目标服务的地址列表,从而完成服务的注册和消费的功能
3. Zookeeper会通过心跳检测,来判断Dubbo服务提供端的运行状态,来决定是否应该把这个服务从地址列表剔除
4. 当Dubbo服务提供方出现故障导致Zookeeper剔除了这个服务的地址, 那么Dubbo服务消费端需要感知到地址的变化, 从而避免后续的请求发送到故障节点, 导致请求失败

#### 动态感知
1. Dubbo服务消费端会使用Zookeeper里面的Watch来针对Zookeeper Server端的/providers节点注册监听
2. 一旦这个节点下的子节点发生变化, Zookeeper Server就会发送一个事件通知Dubbo Client端
3. Dubbo Client端收到事件以后, 就会把本地缓存的这个服务地址删除,这样后续就不会把请求发送到失败的节点上, 完成服务下线感知

#### Dubbo注册中心宕机, 服务间还能继续通信吗
Dubbo的注册中心挂了之后, 服务之间还是可以继续通信的. 主要是因为Dubbo初始化的时候, 消费者会将服务提供者的地址等信息缓存到本地

### Dubbo容错策略
1. 重试的容错机制
* 如果基于Dubbo进行服务间通信出现异常,服务消费者会对服务提供者集群中其他的节点发起重试,确保这次请求成功,默认的额外重试次数是2次
2. 快速失败策略
* 服务消费者只发起一次请求,如果请求失败,就直接把错误抛出去
* 比较适合在非幂等性场景中使用
3. 失败安全策略
* 如果出现服务通信异常,直接把这个异常吞掉不做任何处理
4. 失败自动恢复策略
* 后台记录失败请求,然后通过定时任务来对这个失败的请求进行重发
5. 并行调用多个服务策略
* 把消息广播给服务提供者集群,只要有任何一个节点返回,就表示请求执行成功
6. 广播调用策略
* 逐个调用服务提供者集群,只要集群中任何一个节点出现异常,就表示本次请求失败

## Dubbo与Spring Cloud区别
#### 产生背景
1. Dubbo是SOA时代的产物,它的关注点主要在于服务的调用、流量分发、流量监控和熔断
2. Spring Cloud诞生于微服务架构时代, 考虑的是微服务治理的方方面面.依托于Spirng、Spirng Boot优势

#### 核心要素
1. 在开发过程中Dubbo需要通过实现各种Filter来做定制, 开发成本以及技术难度略高
2. Spring Cloud只要整合其子项目就可以顺利的完成各种组件的融合

#### 协议
1. Dubbo默认采用的是单一长连接和NIO异步通讯,适合于小数据量大并发的服务调用. 以及服务消费者机器数远大于服务提供者机器数的情况. Dubbo底层使用Netty这样的NIO框架, 是基于TCP协议传输的, 配合Hession序列化完成RPC通信
2. SpringCloud是基于Http协议 + REST API调用远程过程的通信.相对来说,Http请求会有更大的报文,占的带宽也会更多. 但是REST相比RPC更为灵活, 服务提供方和调用方的依赖只依靠一纸契约,不存在代码级别的强依赖

#### 服务依赖方式
1. Dubbo服务依赖比较重, 需要有完善的版本管理机制, 但是程序入侵少
2. Spring Cloud是自有生态, 省略了版本管理的问题,它使用JSON进行交互,为跨平台调用奠定了基础

#### 组件运行流程
1. Dubbo的每个组件都是需要部署在单独的服务器上,用来接收前端请求、聚合服务,并批量调用后台原子服务. 每个Service层和单独的DB交互
2. Spring Cloud所有请求都统一通过API网关(Zuul)来访问内部服务. 网关接收到请求后, 从注册中心(Eureka)获取可用服务. 由Ribbon进行均衡负载后,分发到后端的具体实例. 微服务之间通过Feign进行通信处理业务
