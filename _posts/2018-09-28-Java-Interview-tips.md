---
layout: post
title:  "java知识盘点"
date:   2018-09-28 09:00:30 +0200
categories: java
---

java基础知识盘点

## 基本类型
8种基本类型(boolean,byte,char,short,long,float,double),其他类型都是引用类型
### int、Integer区别
* int是java的8个原始数据类型之一 
* Integer是int的包装类，有一个int类型的字段存储数据，通过自动装箱/拆箱(编译阶段),java可以根据上下文自动进行转化;自动装箱valueOf会用到缓存IntegerCache
* *注意: 避免无意中的装箱/拆箱行为，特别在性能敏感场合*

### 为什么基本类型的存储都是8位整数倍？
计算机底层按照Byte为单位操作数据，其他类型设计为8的整数倍，方便拆分和合并处理

## AtomicInteger的底层实现原理
  <img src= "/assets/files/to_be_supplemented.png" alt="加载错误" title="有待补充"/>

## String、StringBuffer、StringBuilder区别
* String是JAVA非常基础和重要的类，提供了构造和管理字符串的各种功能。它是immutable类，其所有属性都是final的，由于不可变性，因此在拼接、裁剪字符串时都会产生新的String对象
* StringBuffer则是为解决上述产生许多中间对象问题而提供的一个类，它是一个线程安全的类，加上了synchronized关键字
* StringBuilder与StringBuffer基本没有区别，只是去掉了synchronized关键字，不再是线程安全的，减少了性能开销，是绝大多数情况下处理字符串的选择

### StringBuffer和StringBuilder底层实现
底层都是利用可修改的char数组（java 9之后为byte数组），继承自AbstractStringBuilder，默认大小是16

## vector、ArrayList、LinkedList区别
* Vector是线程安全的动态数组，内部使用对象数组存储数据，可根据需要自动增加容量（扩容1倍），当数组满时，会创建新数组，并拷贝原有数组数据
* ArrayList时应用更加广泛的动态数组，本身不是线程安全的，与Vector类似也是对象数组保存数据，也会自动扩容，但相比Vector是增加一半
* LinkedList即双向链表，不是线程安全的，也没有扩容问题

### 应用场景
* Vector和ArrayList内部以数组形式顺序存储元素，适合随机访问的场合，除了尾部插入、删除操作外，性能较低
* LinkedList进行节点插入、删除比较高效，但随机访问性能则比上述慢

## Hashtable、HashMap、TreeMap区别
*  Hashtable继承自Dictionary类，是线程安全的，使用synchronized实现，效率比较低，现在更多实用ConcurrentHashMap来实现同步，效率高很多
* HashMap继承自AbstractMap，是应用更加广泛的哈希表，可以存储null键和值，不是同步的，在进行put/get操作时能达到常数时间的性能
* TreeMap也继承自AbstracMap, 利用红黑树实现，并且实现了SortMap接口，能够对保存的记录根据键进行排序(默认升序)，也可以自定义实现Comparator接口来实现排序方式，在进行get/put/remove时可以达到log(n)的时间复杂度

### ConcurrentHashMap
* 1.7 由Segment数组和HashEntry数组组成，即把桶数组切分成更小的segment数组，每个segment有若干HashEntry。每个segment配一把锁（segment继承自ReentrantLock，即可重入锁），当线程占用其中一段的锁时，其他段仍能够被其他线程访问
* 1.8 由Node数组+链表+红黑树的结构组成，在锁的实现上抛弃了原来的segment（segment仍然存在，只是仅用做保证序列化时的兼容性）;
采用CAS+synchronized实现了更加细粒度的锁（synchronized的实现得到了优化，锁不是加在整个节点上，而是链表头上减少了内存开销）

### HashMap源码解读
* HashMap可以看作是Node数组和链表的复合结构，数组被分为一个个桶，通过哈希值决定键值对在数组上的寻址，哈希值相同的则以链表形式存储，链表大小超过默认阈值就会转换成树形结构
* h = key.hashCode() ^ h >>> 16（高位移位到底位进行异或运算）：哈希值的主要差异来自于高位，但hashmap中的哈希寻址是忽略容量上的高位的，这样处理可以有效避免哈希碰撞
* 容量、负载因子、树化

### 哈希冲突解决
  <img src= "/assets/files/to_be_supplemented.png" alt="加载错误" title="有待补充"/>

## synchronized和ReentrantLock区别
* synchronized是jvm内部的内置锁，提供了互斥的语义和可见性，当一个线程获取锁后，其他线程只能等待或阻塞；可以修饰方法或特定代码块
* ReentrantLock即重入锁，语义与前者基本相同，但提供了更多的实用方法，能够做到前者不能做到的细节控制，例如： 设置公平性

### synchronized
* 底层实现完全依赖JVM, 通过进入和退出Monitor对象来实现代码块同步和方法同步的，包括一对monitorenter/monitorexit指令， 而monitor的实现则是依赖操作系统内部的互斥锁，需要进行用户态到内核态的切换，是一个重量级操作

### 锁升级
为了减少获得锁和释放锁来的性能开销，引入了偏向锁、轻量级锁，锁的状态从无锁-偏向锁-轻量级锁-重量级锁，根据竞争激烈的程度从低到高不断升级
* 无锁, 即所有线程都能访问并修改统一资源，但只有一个线程能够修改成功
* 偏向锁, JVM默认， 即在没有多线程竞争时，偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要同步
* 轻量级锁, 即当有其他线程试图获取锁时，偏向锁就会升级为轻量级锁，其他线程会通过自旋形式获取锁，而不会阻塞
* 重量级锁, 即在轻量级锁获取失败时，会进一步升级为重量级锁，其他线程试图获取锁时，都会被阻塞，只有持有锁的线程释放锁之后才会唤醒这些线程，它是原始synchronized的实现

### 偏向锁实现
1.检查对象头中Mark Word是否为可偏向状态，如果不是则直接升级为轻量级锁
2.如果是，判断Mark Work中的线程ID是否指向当前线程，如果是，则执行同步代码块
3.如果不是，则进行CAS操作竞争锁，如果竞争到锁，则将Mark Work中的线程ID设为当前线程ID，执行同步代码块
4.如果竞争失败，升级为轻量级锁

### 自旋锁
自旋锁， 即当线程a持有锁，而线程b竞争锁时，线程b不会阻塞，而是进行自循环等待，当线程a释放锁时，线程b可以马上获取锁。自旋机制可以减少线程阻塞和唤醒时的上下文切换带来的开销；适用于锁竞争不是很激烈且线程占有锁的时间较短的场景，如果锁竞争激烈或者持有锁的线程需要很长时间执行同步块，此时自旋锁一直占用cpu做无用功，其消耗就要远大于线程阻塞挂起操作

## 死锁
死锁是一种特定的程序状态，不仅会发正在线程之间，而且在资源独占的进程之间也可能出现;大多数情况下是指两个或多个线程之间互相持有对方需要的锁，而永远处于阻塞状态
### 死锁的定位
* 通常是利用jstack等工具获取线程栈，然后定位相互之间的依赖关系，进而找到死锁;死锁问题一般不能在线解决,只能重启、修正程序错误; 
* JavaAPI提供了findDeadlockedThreads方法也可以进行定位
* 若某个线程进入了死循环，导致其他线程一直等待，进而发生死锁，这种情况下可以查看线程 cpu 使用情况，排查出使用 cpu 时间片最高的线程，再打出该线程的堆栈信息，排查代码

### 死锁的原因
* 互斥条件, 一个资源只能有一个线程占有
* 互斥条件长期持有，也即在使用结束之前，不会主动释放，也不会被其他线程抢占
* 循环依赖关系, 两个或多个线程之间出现锁的链条环

### 死锁的预防：
* 尽量避免使用多个锁，并且在需要时才持有锁
* 必须使用多个锁时，设计好锁的获取顺序（银行家算法）
* 使用带超时的方法，指定超时时间，并为无法得到锁时准备退出逻辑

## 强引用、弱引用、软引用、幻象（虚）引用区别
* 强引用：即最常见普通对象引用，只要还有强引用指向一个对象，那么该对象就还活着，GC就不会处理它。当对象没有其他引用关系或者超出了引用作用域或者引用被赋值为null时，对象就可以被垃圾收集了
* 软引用：相对强引用较弱，能够使对象豁免一些垃圾收集，只有当JVM认为内存不足时才会试图去回收这些引用指向的对象，以保证不会耗尽内存而抛出Error. 通常用在内存敏感的缓存，如果内存还有空闲，就保留缓存，否则清理掉. *可以与引用队列联合使用，如果引用所指向对象被回收，JVM就会把该引用加入引用队列，之后可以调用相应方法检查对象是否被回收*
* 弱引用：不能让对象豁免垃圾收集,只是提供一种访问在弱引用状态下对象的途径，如果获取时对象还在就使用此对象，否则重现实例化,也常用于缓存的实现.*可以与引用队列联合使用，如果引用所指向对象被回收，JVM就会把该引用加入引用队列，之后可以调用相应方法检查对象是否被回收*
* 幻象引用：指向的对象不能被访问，可以用来跟踪对象被GC回收的活动.*必须与引用队列联合使用，当GC准备回收对象时，若发现还有虚引用，就会在回收之前把虚引用加入引用队列。*

## final、finally、finalize区别
* final可以用来修饰类、方法、变量，final不等于immutable
   * 修饰类代表此类不可被继承扩展；
   * 修饰方法代表此方法不可被重写；
   * 修饰变量代表此变量是不可修改的
* finally是保证重点代码一定被执行的机制，通常可以使用try-finally或try-catch-finally来进行类似关闭文件流、关闭JDBC链接、unlock锁等操作
* finalize是java.lang.Object中的一个方法，目的是保证对象被垃圾收集前完成特定资源的回收.在java9以被标记为弃用

## 代理机制
代理就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以增加许多操作, 例如：预处理消息、过滤消息等
### 代理分类
1. 静态代理: 由程序员自己创建代理类，在程序运行前代理类就已生成
2. 动态代理:
* JDK: 使用Proxy类的newProxyInstance方法来动态生成,动态生成的代理类必须与被代理类实现相同接口，也即有相同行为
* cglib: 使用Enhancer.create方法来动态生成,动态生成一个子类,该子类继承被代理类，并重写其中非final方法
3. 两者区别
* 前者基于反射机制，只能对接口进行代理，因为动态生产的代理类继承自Proxy,而JAVA不支持多继承
* 后者基于ASM框架，通过修改字节码来生成子类，不能给final类生成代理

### 反射
* 反射是指在程序运行状态中，能够取得任何类的内部信息，并能直接操作任意对象的属性及方法，即动态获取信息以及动态调用对象方法的功能
* 使用JDBC时，如果要创建数据库的连接，则需要先通过反射机制加载数据库的驱动程序
* 多数框架都支持注解/XML配置，从配置中解析出来的类是字符串，需要利用反射机制实例化

### Spring的AOP
* 我们用上边的做法去实现目标方法的增强，实现代码的解耦，是没有问题的，但是还是需要自己去生成代理对象，自己手写拦截器，在拦截器里自己手动的去把要增强的内容和目标方法结合起来，这用起来还是有点繁琐
* Spring的AOP就不用自己去写，只需要在配置文件里进行配置，Spring根据不同的情况去决定是使用JDK还是cglib

## 接口和抽象类区别
* 接口是对行为的抽象，是抽象方法的集合，不能实例化，没有非常量成员，没有非静态方法实现，利用接口可实现API定义和实现相分离的目的
* 抽象类除了不能实例化之外，与普通类没有太大区别，可以有抽象方法，也可以没有，抽象类大多用于抽取相关类的共同方法和成员变量以达到代码重用的目的

## 文件拷贝方式
1. io类库中的FileInputStream/FileOutputStream
* 当使用输入输出流进行读写时，先在内核态将数据从磁盘拷贝进内核缓存，然后切换到用户态将数据从内核缓存读取到用户缓存
* 会进行多次上下文切换，IO效率低
   * 使用缓存，减少IO次数
   * 使用transferTo等机制，减少上下文切换
   * 尽量减少不必要的转换，例如：编解码，序列化反序列化
2. nio类库中的transferTo/transferFrom
基于*零拷贝*技术，数据传输不要用户态，省去了上下文切换的开销和不必要的内存拷贝

## 设计模式
1. 创建型: 即创建对象过程中的各种问题和解决方案的总结，例如：工厂模式、单例模式、构建器模式
* 构建器模式： 例如，创建HttpRequest的过程，以及其他创建复杂对象的场景(builder().build())
2. 结构型: 即对软件设计结构的总结，例如： 适配器模式、装饰者模式、代理模式
* 装饰者模式： 例如，InputStream, 它本身是个抽象类，java基础类库提供了FileInputStream、BufferedInputStream等子类，对其从不同角度进行了功能扩展
3. 行为型: 即对类或对象之间交互、职责划分的总结， 例如： 策略、解释器、观察者、模板方法模式

### Spring框架中用到的设计模式
* BeanFactory、ApplicationContext用到工厂模式
* SpringAOP用到代理、装饰器、适配器模式
* 各种事件监听用到观察者模式
* 类似JdbcTemplate用到模板模式


