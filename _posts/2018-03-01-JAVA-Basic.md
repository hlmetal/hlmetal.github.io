---
layout: post
title:  "java基础"
date:   2018-03-01 08:20:30 +0200
categories: java
---

Java是一种面向对象的编程语言，Java还是一个平台, 包括Java软件及其组件,如JRE、JDK、JVM等

## java开发环境
1. java编译运行过程:
    * 编译期：java源文件，经过编译，生成.class字节码文件---只检查语法
    * 运行期：JVM加载.class并运行
2. JVM：java虚拟机，加载.class并运行。
3. JRE:java运行环境，除了包含JVM还包括运行java程序所必须的环境，JRE=JVM+java系统类库。
4. JDK:java开发工具包,除了JRE还包括开发java程序所必须的命令,JDK=JRE+编译，运行等命令。运行java程序最小的环境JRE；开发环境最小的环境JDK
5. 配置环境变量
    * JAVA_HOME：指向JDK安装目录
    * CLASSPATH：表示类的搜索路径
    * PATH：指向JDK下的bin目录

## java开发
1. 注释：1）单行注释：//；2）多行注释：/* *；3）文档注释：/** */；
2. println：输出换行；print：输出不换行
3. 变量：内存中开辟的存储空间，用于存放所需用的数据。变量在使用之前必须声明并初始化,数据类型要匹配
4. 变量的作用域: 从变量的声明开始到包含它最近的大括号结束;作用域重叠时，变量不能同名;
5. 基本数据类型:byte,short，int,long,float,double,char
    * 1B（字节）=8Bit（位），int(4B)，long(8B)，double(8B)，boolean(1B)，char(2B);
    * long 如果要表示long直接量，要加l或L；运行可能溢出时，建议在第一个数字后加L或l;
    * 默认的浮点直接量为double型，若用float则要加F或f;(有舍入误差，精确运算不能使用double，如果需要精确地运算可以用BigDecimal类实现)
    * double的精度值为float的两倍；
    * 字符char，实质上是码int(0到65535)；必须放在单引号中，有且仅有一个;
    * 特殊符号用\转义	ASCⅡ码（‘a’--97;'A'--65;'0'--48）；
    * 基本类型转换,自动类型转换:从小类型到大类型;强制类型转换:从大类型到小类型;强转有可能溢出或精度丢失;整数直接量可以直接赋值给byte，short，char,但不能超出范围;byte，short，char参与运算时一律转换成int再运算;
6. 运算符
    * 算术运算符：\+，\- \*，/，%，++，--；++单独使用时不分前后（a++，++a），被使用时，a++为a，++a为a+1
    * 关系运算：>,<,>=,<=,==,!=;关系运算的结果为boolean型，关系成立则true，不成立则false
    * 逻辑运算符：&&，\|\|，！
    * 短路与：第一个值为false时,发生短路（后边不执行），短路或：第一个值为true时，发生短路
    * 三目/条件运算符：boolean？数1：数2；计算boolean的值为true则结果为数1，否则为数2；
7. 分支结构:有条件的执行某语句1次，并非每句必走
if...else...;if...else if....;switch...case:(case:1相当于if（）==1)...;
8. 循环结构: 有条件的执行某语句多次，并非每句必走；反复执行一段相同或相似的代码；
    * 循环三要素：1）循环变量的初始化；2）循环的条件；3）循环变量的改变;
    * while 先判断后执行
    * do...while 先执行后判断,要素1和3相同时首选do..while;for 固定次数循环
    * break:跳出循环；只能跳出1层循环；
    * continue:跳过循环体中的剩余语句，进入下一次循环；
9. 随机数：1）Math.random( ); (0.0-0.9999999...之间),要产生1-1000的随机数则： (int)(num*1000+1)或(int)(num*1000)+1;
10. 循环应用：
    * 1+1/2+1/3+……+1/n：sum=sum+1.0/i; 
    * 9+99+999+……+99999..:num=num*10+9;sum+=num;
    * “直到...."：优先选择do-while（获取密码，直到输入的值....），要素1与3相同时;
    * “当....”while;要素1与3不同时;
    * 循环嵌套：九九乘法表;
    * 外层循环走一次，内层循环走所有次；循环层数越少越好，超过三层，说明设计有问题。
11. 数组：相同数据类型数据的集合
    * 程序=算法（解决问题的流程/步骤）+数据结构（将数据按照某种特定的结构保存）
    * 数组是最基本的数据结构；
    * 数组定义：`int [] arr = new int[4];`  默认值为0；数组声明时不规定长度，new关键字分配空间时需指定分配空间大小；
    * 数组初始化：`int[] arr={1,2,3,4};或int[] arr = new int[]{1,2,3,4};`
    * 数组访问：通过（数组名.length）可以获取数组长度；通过下标/索引访问数组中的元素，下标从0开始，最大为数组长度-1
    * 数组的遍历 `for（int i;i<arr.length;i++）{ arr[i]=(int)(Math.random()*100) }`
    * 数组的复制：
        ```
        //a为源数组；1为源数组下标；a1为目标数组；0为目标数组起始下标；4为要复制的元素个数
        system.arraycopy(a,1,a1,0,4);
        //生成的数组为源数组的副本，newLength小于源数组则进行截取，大于则用0或null填充
        Arrays.copyOf(类型[] original.int newLength);
        ```
    * 数组扩容(创建一个新数组)：`a=arrays.copyof(a,a.length+1);`
    * 数组的排序：数据不同，排序算法效率不同；Arrays.sort(arr);//默认升序

12. 方法（函数，过程）
用于封装一段特定的逻辑功能。方法尽可能独立，一个方法只干一个事.可以被反复调用很多次,避免代码重复,有利于代码的维护，有利于团队协作
* 方法可以有返回值也可以没有,无返回值，返回值类型为viod;有返回值，返回值类型写为具体的数据类型
* 定义方法：五要素：修饰词，返回值类型，方法名，参数列表，方法体；
* 方法调用：无返回值：方法名（有参传参）;有返回值：数据类型 变量 =方法名（有参传参）
* return：结束方法的执行，返回一个值给调用方；无返回值方法中。结束方法执行
```java
//猜字符游戏
//1.设计数据结构：
char[] chs;//随机字符数组
char[] input;//用户输入字符数组；
int letterRight;字符正确数；
intpositionRight;字符位置正确数；
int[] result;对比结果；
int score；//得分；
int count;//猜错的次数；
//2.设计程序结构：
//生成随机字符数组
public static chs char[]  letter(){
char[] chs = new char[5];
...
return chs;
 }
//对比结果
public static int[] check(char[] chs,char[] input){
int[] result = new int[2];
...
return result;
}
//3.设计算法：
String str =“ABCDE”
char[] input= str.toCharArray();
str=str.toUpperCase();
str=str.toLowerCase();
str.equals();
```
13. 类和对象
* 类：类型/类别，代表一类个体,类中可包含：
    * 所有对象所共有的属性/特性——变量
    * 所有对象所共有的行为——方法
一个类可以创建多个对象，同一个类的对象，结构相同，数据不同
* 类是对象的模板，对象是类的具体实例,类是数据类型并且是引用类型
* 引用类型之间划等号：引用类型之间赋值不会创建新的对象，但有可能会使两个以上的有引用指向同一个对象
14. 方法重载、构造方法
* 方法的签名：方法名和参数列表，一个类中不能有2个方法的签名完全一样，如果两个方法只是方法名相同，参数列表不同是可以的。
* 方法重载（Overload）：同一个类中，方法名相同，参数列表不同，编译时根据签名自动绑定调用方法。与返回值类型无关。
* 构造方法：给成员变量赋值，构造方法名与类名相同，无返回值类型；无构造时，系统默认一个无参构造；创建对象时自动调用；构造方法可以重载；
* this：用在方法中；方法中访问成员变量之前默认有个this.例如：this.number;指代当前对象
14. 引用类型数组
* 引用类型数组默认值为null
```java
Studnet[] stu =new Student[];
 stu[0]=new Student(1,2);
stu[1]=new Student(3,4);
//简写
Student[] stu = new Student[]{new Student(1,2),new Student(3,4)};
//声明int[]型数组arr，包含2元素；每个元素都是int[]型，默认值为null；
int[][] arr = new int[2][];
  arr[0]=new int[2];
  arr[1]=new int[3];
  arr[0][0]=1;//给arr中第1个元素中的第一个元素赋值为1；
arr------int[][]; arr[0]-----int[]; arr[0][0]-----int;
int[][] arr=new int[2][3];//2行3列
for(int i=0;i<arr.length;i++){
    for(int j=0;j<arr[i].length;j++){
    arr[i][j]=1;
    }
}
```
15. 内存管理
内存管理，由JVM来管理内存；分为 栈，堆，方法区
* 堆：用于存储所有new出来的对象（包括成员变量）,没有任何引用所指向的对象是垃圾
    * gc（垃圾回收器）不定时到内存中清理垃圾；回收过程透明，不一定发现垃圾就回收，调用System.gc（）可以建议虚拟机快速调度GC来回收；
    * 内存泄漏：不再使用的内存没有及时回收，对象不再使用时应及时将引用设置为null；
    * 成员变量的生命周期：创建对象时存储在堆中，对象被回收时消失；
* 栈：存储正在调用中的方法中的所有局部变量（包括参数）,调用方法中在栈中为该方法分配一块对应的栈帧，栈帧中存储方法中所有局部变量（包括参数），方法结束，栈帧清除，局部变量一并清除。
    * 局部变量的生命周期：方法调用时存储在栈中，调用结束时，被清除；
    * 局部变量无默认值；
* 方法区：存放类的信息（.class）字节码文件；方法只有一份，使用this来区分具体对象；


16. 继承（泛化）
* 实现代码的复用
* 父类（基类）中是所有子类共有的属性和行为，子类（派生类）中为特有的属性和行为
* 继承具有传递性
* 子类能访问父类，父类不能访问子类
* 一个子类只能继承一个父类----单一继承；一个父类可以有多个子类；
* 构造子类之前必须先构造父类；子类构造方法中若不调用父类的构造方法，则默认super（）调用父类无参构造
    * super:指代当前对象的父类对象；
    * super.成员变量名——调用父类的成员变量
    * super.方法名()——调用父类的方法
    * super()——调用父类的构造方法
    * super关键字必须在子类构造方法的第一行
    * 向上造型：父类型的引用指向子类的对象
16. 方法的重写（覆盖）
* 发生在父子类中，方法签名相同，方法体不同；
* 重写方法被调用时看对象的类型；
* 两同两小一大原则：
    * 两同：方法名和参数列表相同;
    * 两小：子类方法的返回值类型小于或等于父类的,子类方法抛出的异常小于或等于父类的
    * 一大：子类方法的访问权限大于或等于父类的；
* 重写与重载的区别	
    * 重写：发生在父子类中，方法签名相同；遵循 运行期绑定，看对象的类型调用方法；
    * 重载：发生在同一类中，方法名相同，参数列表不；遵循 编译期绑定，看引用的类型调用方法；
17. package和import：
* package:避免类名冲突,包一般都是有层次结构的：域名反写.项目名称.模块名称；且小写（建议包名命名方式）;类的名称：包名+类名；
i* mport：同一包中类可直接访问；不同包不能直接访问；有两种访问方式：类全称或通过import语句对类进行声明
18. 访问控制修饰符
* public：公开的，任何类；private：私有，本类中可用；protected：受保护的
* 类的访问修饰：public和默认
* static关键字:
    * 实例变量：没有static修饰,属于对象,存在堆中有几个对象就有几份,通过（对象.）来访问
    * 静态变量：有static修饰，属于类的，存在方法区中；只有一份；一般通过（类名.）来访问
    * 何时用：所有对象共享的数据（图片，音频，视频等）
    * 静态方法：有static修饰，属于类的，存在方法区中；只有一份；一般通过（类名.）来访问
    * 静态方法中没有隐式的this传递，不能直接访问实例成员
    * 何时用：方法的操作仅与参数相关而与对象无关
    * 静态块：属于类，在类被加载期间自动执行，类只被加载一次，所以静态块也只执行一次
    * 何时用：常常用于加载/初始化静态资源（图片，音频，视频等）
* final：最终的,可用于修饰变量，方法（则方法不可被重写），类（则类不可被继承）
    * final修饰成员变量，声明的的同时或构造方法中初始化；修饰局部变量，用之前初始化即可；
    * static final常量：声明的同时初始化，不可改变，通过（类名.）访问；常量一般全部大写，多个单词用_分隔
19. 抽象、接口
* 抽象类：由abstract修饰，包含抽象方法的类必须是抽象类；抽象类不能被实例化,抽象类是需要被继承的，则子类要重写所有抽象方法,没有抽象方法的类也可以被声明为抽象类
* 抽象类的意义
    * 封装所有子类共有的属性和行为——代码复用
    * 为所有子类提供了一种统一的类型——向上造型
    * 可以包含抽象方法，为所有子类提供一个统一的入口
    * 子类的具体实现不同，但入口是一致的；
* 接口：是一个标准，规范——制定方；遵守了这个标准的就能干某件事——遵守方。
    * 接口是一种数据类型（引用类型）由interface定义，接口中只能包含常量和抽象方法
    * 接口不能被实例化；
    * 接口是必须被实现的（implements)，实现类必须重写接口中的所有抽象方法；
    * 一个类可以实现多个接口，用逗号分隔
    * 有继承又有实现的时候，则先继承后实现
    * 接口可以继承接口
    * 接口是对继承的单根性的扩展——多继承；
* 设计规则
    * 将所有子类共有的属性和行为，抽象到父类；
    * 将所有子类相同的行为设计成普通方法，不同行为设计成抽象方法；
    * 部分子类共有的行为，抽象到接口中，符合既是.....也是....的原则时，使用接口；
20. 多态、成员内部类、匿名内部类
* 多态
    * 同一个类型的引用指向不同对象时，有不同的实现——行为多态；
    * 同一个对象被造型为不同的类型时，有不同的功能——对象的多态；
* 成员内部类：类中套类，里面的称为inter内部类，外面的称为outer外部类；
    * 内部类通常只服务于外部类，对外不具备可见性；
    * 内部类对象通常在外部类中创建；
    * 内部类中可以访问外部类的成员（包括私有的）
    * 内部类中有个隐式的引用指向了创建它的外部类对象；
* 匿名内部类：若想创建一个类（子类）的对象，并且对象只被创建一次，此时该类不必命名；
    * 匿名内部类中想访问外部变量，则外部变量必须是final的；

## 面向对象总结
* 封装：
    * 类：封装的是对象的属性和行为；
    * 方法：封装的是特定的业务逻辑功能；
    * 访问控制修饰符：封装的是访问的权限；
* 继承：
    * 实现代码复用；
    * 父类：所有子类共有的属性行为，子类：子类特有的属性行为；
    * 子类继承父后，子类具有父类及子类；
    * 所有类的默认父类为Object；
    * 单一继承，多接口实现，传递性；
* 多态：
    * 行为的多态，对象的多态；
    * 向上造型，强转，instanceof；
    * 多态的表现形式：
    * 重写：根据对象来实现多态；
    * 重载：根据参数来实现多态；

## JAVA Stream
### 什么是Stream
Stream是对集合(Collection)对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作(aggregate operation),或者大批量数据操作(bulk data operation)。Stream API借助于同样新出现的Lambda表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序
### Stream与Iterator
Stream不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。
* 原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；
* 高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。
* Stream 可以并行化操作，迭代器只能命令式地、串行化操作。
    * 当使用串行方式去遍历时，每个 item 读完后再读下一个 item。
    * 而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。
    
### Stream特性
1. 不是数据结构, 没有内部存储, 它只是用操作管道从source（数据结构、数组、generator function、IO channel）抓取数据。
2. 它也绝不修改自己所封装的底层数据结构的数据。例如Stream的filter操作会产生一个不包含被过滤元素的新Stream，而不是从source删除那些元素。
3. 所有Stream的操作必须以lambda表达式为参数
4. 不支持索引访问
5. 很容易生成数组或者List
6. 惰性化, 很多Stream操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。Intermediate 操作永远是惰性化的。
7. 并行能力,不需要再写多线程代码，所有对它的操作会自动并行进行的。
8. 集合有固定大小，Stream 则不必。limit(n)和findFirst()这类的short-circuiting操作可以对无限的Stream进行运算并很快完成。

## JAVA API
### String及其常用API
#### String概念
String字符串是不可变对象,创建后内容不可改变，改变内容会创建新对象，字符串通常使用字面量形式创建，因为字面量形式创建的字符串对象会缓存在常量池中被重用，减少大量内容一样的字符串对象对内存的不必要开销。
#### 常用API
1. lenght(); 返回当前字符串的长度
2. int indexOf(String str)返回给定字符串在当前字符串中的位置，若当前字符串不含有给定字符串则返回-1,否则返回下标
3. String substring(int start,int end);截取当前字符串指定范围内的字符串并返回,在java api中通常使用两个数字表示范围时，都是“含头不含尾”的
4. String trim();去掉当前字符串两边的空白字符
5. char charAt(int index);返回当前字符串中指定位置的字符
6. boolean startWith(String str);boolean endsWith(String str);判断字符串是否是以给定字符串开始或结尾的
7. String toUpperCase();String toLowerCase();将当前字符串的英文部分转换为全大写或全小写
8. static String valueOf(...);将java其他类型转换为字符串,常用于将基本类型转换为字符串
9. split(regex);将字符串按匹配到的位置切开,切除匹配到的字符,将切开的结果保存到字符串数组
10. replaceAll(String regex,String replacement)将字符串中匹配到的正则规则regex的字符替换成replacement

#### StringBuilder
StringBuilder是为了解决频繁修改字符串对系统资源开销问题。
1. StringBuilder内部是个可变的字符数组, 可以通过扩容实现长度变换,而不是每次都创建新对象。
2. StringBuilder提供了方便修改字符串内容的方法。
    * append()方法是用于将给字符串拼接到当前字符串末尾
    * replace()将当前字符串中指定范围内的内容替换为给定内容
    * delete()删除指定范围内的内容
    * insert()在当前字符串指定位置插入
    * reverse()反转字符串

#### 正则表达式
1. 预定义字符集
    * . 任意字符
    * \d 任意数字0-9
    * \D非数字字符
    * \s空白字符，相当于[\t\n\x0B\f\r]
    * \S非空白字符
    * \w单词字符 [a-zA-Z0-9_ ]
    * \W非单词字符
2. 数量词
    * X? 表示0个或1个x
    * X*表示0个或任意多个X
    * X+表示1个到多个任意多个X(大于等于1个X)
    * X｛n｝表示n个X
    * X{n,}表示n到任意多个X(大于等于n个X)
    * X{n,m}表示n到m个X
3. 边界检查
    * "^"和"$"：相当于matches（）方法; ^代表字符串开始,$代表字符串结束\
	
### Object类
任何类都继承于Object，是Object的子类，可以定义变量，引用任何类型（子类型）的对象。Object中定义了全体类共同的方法，子类会自动继承这些方法。
1. toString（）方法就是定义在Object类上定义的方法，是留给全部子类的方法
2. equals（）方法

### Calendar API
1. int get(int field) 获取指定时间分量
2. void set(int field,int value)对指定时间分量设置指定的值
3. void add(int field,int value)对指定时间分量加给定值，若传入的值为负数，则减去给定的值

### Collection API
#### ArrayList和LinkedList
1. 前者是动态数组实现的list, 后者是链表实现的list
2. 插入、删除：void add();  remove();
3. subList:子列表：主列表和子列表共享一个存储空间
4. List转换为数组: Collection类提供的。数组转换为List: Arrays类提供的静态方法asList
5. List排序：sort()、compareTo()
    * Compareable接口：String Date,Integer都有compareTo方法比较两个字符串比较大小
    * 实现Compareable接口，包含copmareTo方法的类称为可以进行默认排序的类型
    * compareTo（）方法；compareTo比较为0时，equals比较结果必须为true；
6. 自定义排序：Collections.sort(list,比较器)
    * 对list集合中的对象没有限制，必须提供“比较器”对象
    * sort方法会利用比较器进行比较排序,用途广泛，可以进行任意数据的比较排序
7. 自然排序：Collection.sort(list)
    * list集合中的元素必须实现Comparable接口，必须实现compareTo方法
    * 一般用于Java对提供的API对象进行排序 String,Date,Integer,Double等

#### 队列（Queue）和栈
1. 队列：先进先出原则，首尾增删, 例如：排队（如游戏的排队系统）
2. 栈：先进后出原则, 例如：前进后退按钮

### File API
1. createNewFile(); 创建文件
2. boolean exists(); 判断当前file表示的文件或目录是否存在
3. delete(); 删除文件
4. IS与OS
* InputStream抽象类：
    * int read();读取一个字节，以int形式返回，该int值的低八位有效，返回-1则EOF
    * int read(byte[] d);
* OutputStream抽象类：
    * void write(int d)
    * void write(byte[] d)
* 文件流、缓存流、对象流、字符流、转换流、缓冲字符输入输出流

### Exception API
1. Throwable类派生的Error和Exception子类
    * try-catch-finally
    * throws: 不要在main方法上写throws
2. 非检查异常：RuntimeException类：NullPointException，ArrayIndexOutBoundsException等
3. printStackTrace()输出错误堆栈信息; getMessage()获取错误消息; getCause()获取异常出现的原因

### Thread API
#### 线程状态
<img src= "/assets/files/thread_status.jpg" alt="加载错误" title="线程状态"/>

#### 线程操作
1. Thread.currentThread方法：用于获取运行当前代码片段的线程，返回一个线程实例
2. 获取线程信息
    * long getId();返回该线程的标识符
    * String getName();名称
    * int getPriority();返回线程的优先级
    * Thread.state getState();获取线程的状态
    * boolean isAlive;测试线程是否处于活动状态
    * boolean isDaemon();测试线程是否为守护线程
    * boolean isInterrupted();测试线程是否已经中断

#### 多线程并发安全问题
1. 当多个线程并发访问同一资源时,由于线程切换不确定,导致的代码执行顺序混乱从而出现很多问题,严重时可能导致系统瘫痪
2. 同步块synchronized(t){}
    * 有效的缩小同步范围可以在保证安全的前提下提高代码并发执行的效率;
    * 静态方法上使用其修饰后，该方法一定具有同步效果;
3. 互斥锁
使用synchronized修饰的是多端代码,但是这些同步块的同步监视器对象是同一个的时候，这些代码间就具有了互斥效果,同一时间多个线程不能同时在这些方法内部执行;

#### 线程安全API
1. StringBuilder不是线程安全的，而**StringBuffer是线程安全的**，所以在多线程下操作同一个字符串内容时应当使用StringBuffer,因为该类中的操作字符串相关方法都是同步方法(使用Synchronized修饰)
2. List集合常用的实现类：ArrayList，LinkedList; Set集合的实现类：HashSet; Map集合的实现类：HashMap**都不是线程安全的**，但是可以通过集合的工具类Collections的相关方法转换为一个线程安全的

#### 线程池
使用ExecutorService实现线程池: 控制线程数量，重用线程
* Executors.newCachedThreadPool()创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们
* 常用Executors.newFixedThreadPool(int nThreads)创建一个可重用固定线程集合的线程池，以共享的无界队列方式来运行这些线程
* Executors.newScheduledThreadPool(int corePoolSize)创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行
* Executors.newSingleThreadExecutor()创建一个使用单个worker线程的Executor，以无界队列方式来运行该线程

## XML语法
XML指可扩展编辑语言，独立于软件和硬件的信息传输工具，常用于简化数据的存储和共享
* XML多大小写是敏感的，起始和结束标签大小写必须一致。
* 根标签：只允许只有一个，不在被其他标签包含的
* 标签必须正确嵌套

1. 实体引用：实体可以是常用的短语，键盘字符，文件，数据库记录或任何包含数据的项，有时实体中包含一些字符需要转义
```
&lt;         <      小于
&gt;        >      大于
&amp;    &   与字符
&apos;    '   单引号
&quot;    "   双引号
CDATA段：<![CDATA[     ]]>   所有内容被当成一整块文本数据
<!--    --> 注释
```
2. SAX解析方式：是一种XML解析的替代方法，相比于DOM，SAX是一种速度更快，更有效的方法。
    * 优点：解析可以立即开始，速度快，没有内存压力
    * 缺点：不能对节点做修改
3. DOM解析方式：W3C推荐的处理XML的一种方式。
    * 优点：把xml文件在内存中构造树形结构，可以遍历和修改节点
    * 缺点：如果文件比较大，内存有压力，解析时间会比较长
