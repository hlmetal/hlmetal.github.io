---
layout: post
title:  "重新认识Java"
date:   2023-03-05 09:00:30 +0200
categories: java 
---

谈谈对java的粗浅理解, java不仅是一种语言, 也是一个平台, 它包括java运行环境、jVM、以及write once, run everywhere等特性

## JDK主要版本的特性
### [java8](https://www.oracle.com/java/technologies/javase/8-whats-new.html)
#### lambda表达式
#### StreamAPI（流的操作）
1. 创建流（集合）->筛选、过滤、去重、排序、映射map->收集(集合) 
* 普通收集： toList/toSet
* 高级收集： toMap/groupingby

#### 新日期时间API
* local DATe Time、时间戳、格式化

#### Opational类
* 优化对null的处理，使代码更加健壮
* 链式取值： 层层嵌套对象取值，只有上层对象不为空时才能读取其属性值，然后继续调用，取出最终结果

### [java9](https://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNEW-GUID-C23AFD78-C777-460B-8ACE-58BE5EA681F6)
#### 模块化
* javaSE程序更容易轻量级部署:jlink
* 改进组件间的依赖管理:module-info.java、requires\exports
* 改进性能和安全性：可读性、可访问性

#### jshell
交互式解释器.使Java 可以像 Python一样在 Shell 中运行代码并直接得出结果
#### StreamAPI增强
* takeWhile、dropWhile、ofNullable
* iterate的新重载方法可自定义终止逻辑

#### 不可变集合新创建方式of()方法
#### 垃圾收集器默认G1（之前是Parallel）
* 与 Parallel GC 相比，它减少了暂停时间

### [java11](https://www.oracle.com/java/technologies/javase/11-relnote-issues.html#NewFeature)
#### 字符串API增强
* isBlank(判断非空), strip(去空格), lines(换行)等等API
#### var可用于lambda表达式
#### 标准HttpClientAPI， 与Apache HttpClient、Jetty类似，支持Http2.0,也兼容1.1
#### 简化Java编译运行命令，以前先编译javac再运行java；现在只需一个命令java
#### ZGC（java15正式发布）
* 进一步减少停顿，可以将未使用的已提交内存返回给操作系统

#### 飞行记录器
* 是一种低开销的事件信息收集框架，主要用于对应用程序和 JVM 进行故障检查、分析

### [java17](https://www.oracle.com/java/technologies/javase/17-relnote-issues.html#NewFeature)
#### 新增文本块
* 之前版本要定义字符串，如JSON，相对麻烦，在17中更加便捷易读，更方便格式调整

#### switch表达式
* 允许switch有返回值, 不再有break，让switch块更易读

#### 密封类
* 可以更好的控制哪些类可以对超类进行继承，子类则可以是密封的、非密封的或final的

#### instanceof模式匹配
* 可以将类型转换和变量声明都在if中处理从而简化代码

#### Helpful NullPointerExceptions
* 准确显示发生NPE的精确位置

#### 增强的伪随机数生成器
* 增加了新的接口类型和实现，让在代码中使用各种 PRNG 算法变得容易许多
* 增加了 RandomGenerator 接口，为所有的 PRNG 算法提供统一的 API，并且可以获取不同类型的 PRNG 对象流
* 增加了一个新类 RandomGeneratorFactory 用于构造各种 RandomGenerator 实例

## JVM
### 内存区域划分
* **程序计数器**: 每线程一个，任何时间一个线程只有一个方法执行，其会存储当前方法的JVM指令地址
* **Java虚拟机栈**: 每线程一个， 存储栈帧，一个栈桢对应一次方法调用，一个方法中调用了另一个方法，则会创建一个新的栈帧，成为新的当前帧
* **本地方法栈**: 每线程一个， 支持本地方法调用
* **堆**: 每进程一个， 被所有线程共享，所有对象实例都在堆中，堆还可以细分为老年代、新生代等
    * 新生代:即大部分java对象创建、销毁的区域，其内部又分为Eden、survivor区域；Eden又分为多个缓存区，是对象初始分配的区域， survivor区则存放GC中存活下来的对象
    * 老年代:即存放长生命周期的对象，大多数都是从survivor区拷贝过来的对象，也会存放在新生代Eden区中放不下的超大对象
* **方法区**: 每进程一个， 被所有线程共享， 用于存储元数据，例如：类结构信息、运行时常量池、字段、方法代码等
* **运行时常量池**: 方法区中的一部分，存放各种常量信息，例如： 字面量、符号引用

### 监控和诊断JVM堆内外内存使用
* 利用图形化工具，例如：JConsole、VisualVM、JMC
* 利用命令行工具， 例如: jstat、jmap
* GC日志

### OOM
JVM 内存不够用，也即没有空闲内存，并且垃圾收集器也无法提供更多内存
* 在抛出异常之前，通常垃圾收集器会被触发，尽可能清理出空间；不过，也不是在任何情况下垃圾收集器都会被触发。
    * 例如，在去分配一个超大对象时，超过了堆的最大值，JVM 可以判断出垃圾收集并不能解决这个问题，会直接抛出 OutOfMemoryError
* 原因
    * 堆内存不足：例如：内存泄漏、堆大小不合理
    * java栈和本地方法栈：例如： 递归方法中没有退出条件，会一直进行压栈操作，JVM在判断内存不足进行扩展栈空间失败时就会抛出

### ClassLoader
  <img src= "/assets/files/to_be_supplemented.png" alt="加载错误" title="有待补充"/>

### GC
#### 类型
* SerialGC：单线程垃圾收集器，在Client模式下JVM的默认GC， 采用标记-整理算法
* ParNewGC、CMSGC：是一个新生代GC实现，实际上是SerialGC的多线程版本，通常与老年代的CMS GC配合使用； CMSGC采用标记-清除算法，存在内存碎片化问题
* ParallelGC：吞吐量优先GC，算法与SerialGC类似，新生代老年代GC都是并行进行的
* G1GC：兼顾吞吐量和停顿时间的GC, java9默认GC，其内存结构不是条带状划分，而是像棋盘一样划分为一个个region， 采用标记-整理算法
* ZGC：支持 T bytes 级别的堆大小，并且保证绝大部分情况下，延迟都不会超过 10 m

#### 垃圾收集
##### 对象实例收集
* 引用计数法：即为对象添加引用计数，若计数为0，则表示对象可回收
* 可达性分析：即从一个被选为GC ROOTS的对象开始向下搜索，如果一个对象到GCROOTS之间没有引用链相连，则这个对象就是不可达，该对象经过两次标记仍为可回收对象，则该对象则面临回收。Java虚拟机栈、本地方法栈中引用的对象，方法去中静态属性和常量引用的对象都可以作为GCROOTS的对象
* 方法区中的元数据等收集

##### 算法
* 复制算法， 新生代GC一般都是该算法，将Eden区中活着的对象复制到survivor区中的to区域
* 标记-清除
* 标记-整理

##### 流程
java创建的对象通常分配在Eden区域，在Eden空间占用达到阈值后，会触发minorGC，存活的对象将被复制到Survivor中的某一块；当再次出发minorGC时，Eden中存活对象和From区对象将被复制到to区；在此过程中，对象每复制一次其生命周期都会加1；当对象生命周期达到阈值，就会晋升到老年代

#### 调优
* 通常关注内存占用、延时、吞吐量三个目标；大多数情况下调优侧重其中1到2个目标。
* 确定应用需求和问题——>确定调优目标——>掌握JVM和GC状态——>思考GC类型选择是否符合应用需求——>确定具体调整参数和软硬件配置——>验证

## 语言特性
### 面向对象
#### 基本要素
* 多态即重写、重载、向上转型等
* 继承是代码复用的基础，是一种比较紧耦合的关系，父类修改，子类也会变动，不能过度滥用
* 封装的目的是隐藏事务内部的实现细节，以便提高安全性和简化编程，它提供了合理的边界，以防止外部调用者接触到内部细节。比如多线程环境下暴露内部状态，导致并发修改的问题

### 设计原则
* 单一职责，即类或对象只有单一职责，若承担多种义务可以考虑拆分
* 开关原则， 即设计要对扩展开放，对修改关闭，也就是说应当保证平滑的扩展，避免因新增同类功能而修改已有实现
* 里氏替换， 即进行继承关系抽象时，凡可以用父类的地方，都可以用子类替换
* 接口分离， 即接口中不要定义太多方法，应视情况拆分出多个接口，将行为解耦，在未来维护中某个接口设计有变，不会影响使用其他接口的子类
* 依赖反转， 即高层次模块不应该依赖低层次模块，而应该基于抽象
 
 ### 泛型
 ### 反射
 ### lambda
   <img src= "/assets/files/to_be_supplemented.png" alt="加载错误" title="有待补充"/>

## 性能分析
### 后台服务变慢如何诊断
* 首先分析是突然变慢还是长时间运行后变慢、是否重复出现
* 问题有可能来自于自身服务， 也可能是受系统中其他服务影响
* 先检查应用自身的错误日志，看是否大量出现了某种异常，如果没有，再监控CPU、内存等资源占用情况； 还可以监控GC日志，检查是否出现full GC等恶劣情况等


## 核心类库
### 异常机制
#### java.lang.Throwable
* Exception：程序正常运行期间可以预料到的意外情况，能够并且应该被捕获并做出相应处理，通常是编程导致的轻微错误
    * 例如：NullPointException
* Error：在正常情况下不大可能出现情况，绝大部分的error都会导致程序处于非正常、不可恢复状态， 通常是JVM无法解决的严重错误
    * 例如：OutOfMemoryError、NoClassDefFoundError

#### Excepotion和Error区别
#### 检查异常和不检查异常区别
* 前者是在编写源代码期间就必须显示地捕获处理的异常，这是编译检查的一部分；例如： IOException、ClassNotFoundException
* 后者又称为运行时异常，在编译时不会强制检查，但运行时会出错，通常可以通过编码来避免逻辑错误，具体根据需要来判断是否需要捕获; 
* 例如： ArrayIndexOutofBoundsException、ClassCastException（类型转换异常）,未作任何处理，JVM默认会把异常的名称、异常的原因以及异常出现的位置等信息输出在控制台并终止运行

#### try-catch-finally
* try块中是可能发生异常的业务代码；
* catch块中则是对捕获异常的处理，例如重试、打印堆栈信息、回滚事务等等；
* finally块中则是处理一些资源回收等操作

#### 实践注意事项
* try-catch代码段会产生额外的性能开销， 尽量不要用一的大的try包住整段代码，而仅仅放入可能发生异常的代码，也不要用异常来控制代码流程，这远比if/else低效
* 尽量不要捕获类似Exception的通用异常，而应当捕获特定异常，这不仅能够更加直观的体现出异常信息，保证程序不会捕获我们不需要捕获的异常，而且对于上层调用方来说也能够更好的根据不同业务情况处理异常
* 不要生吞异常，如果不把异常抛出来或输出到日志，在程序出现错误时就没办法快速判断和修复问题
* 遵循throw early, catch late原则

#### 反应式编程（异步）异常处理
* traceId串联

### BIO/NIO/AIO
#### BIO
* java.io提供的IO功能，例如File抽象，输入输出流等；是同步、阻塞的方式，即在读或写完成之前，线程会一直阻塞，优点是简单直观，缺点是效率和扩展性有限

#### NIO
* java.nio提供了Channel、Selector、Buffer等，可以构建多路复用、同步非阻塞的IO
* NIO由Buffer、Channel、Selector组成
* 利用单线程轮询事件的机制确定准备就绪的channel来决定做什么，仅select阶段是阻塞的

#### AIO
* java.nio2是一种异步非阻塞的IO方式，基于事件和回调机制
* 基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作

#### java.net中提供的部分网络API，如Socket、ServerSocket等也可以看多是同步阻塞的IO
 
### 并发
#### 线程安全
保证多线程环境下共享的、可修改的数据的正确性，方式例如：封装、不可变
##### 基本特性
* 原子性， 即相关操作中途不会被其他线程干扰，一般通过同步机制实现
* 可见性， 即一个线程修改了共享变量，其他线程能够立即知晓，使用volatile保证可见性
* 有序性， 即保证线程内串行语义，而不是并行，以避免指令重排

#### 线程
从操作系统角度，可以简单理解为系统调度的最小单元，一个进程中有多个线程，是人物的真正执行者，有自己的栈、寄存器、本地存储等，线程之间共享文件描述符、虚拟地址空间等；java线程不允许启动两次，第二次调用会抛运行时异常异常illegalThreadStateException
##### 生命周期
* 新建, 被创建但尚未启动
* 就绪, 已在JVM中执行，可能正在运行，也可能在等待分配cpu片段，在就绪队列中排队
* 阻塞, 等待monitor lock
* 等待, 等待其他线程采取操作，例如： 生产者消费者模式中，若任务条件尚未满足，就会让消费者线程等待，生产者线程去准备任务数据，之后通知消费者线程继续工作
* 终止, 线程完成任务，终止运行，也即线程死亡

#### Executor框架
##### 组成
* Executor基础接口， 只有一个execute方法
* ExecutorService继承了Executor，提供了更完善的功能，包括shutdown、submit等方法
* Executors提供了各种方便的静态工厂方法
* ThreadPoolExecutor、ScheduledThreadPoolExecutor等线程池的实现

##### 线程池
通常都是用Executors提供的创建线程池的方法去创建不同配置的线程池，主要主要区别在于不同的ExecutorService以及初始参数
* newCachedThreadPool： 用于处理大量短时任务，其特点是会缓存线程并重用，无缓存线程时就创建新的线程，默认线程keepAlive为60s,超过60s就会被终止并移出缓存，内部使用synchronousQueue作为工作队列
* newFixedThreadPool： 重用指定数目的线程，内部使用无界队列，若工作任务超过指定数目线程，就会等待空闲线程出现。如果有线程终止，就会创建新线程，以补足指定的线程数目
* newSingleThreadExecutor： 创建线程数为1的线程池，保证任务顺序执行，一次只有一个任务执行， 内部使用无界队列
* newSingleThreadScheduledExecutor/newScheduledThreadPool： 创建单个或多个线程以进行定时的工作调度
* newWorkStealingPool

##### 线程池的实现
* 工作队列， 即负责存储用户提交的任务，容量可以为0，也可以指定大小
* 内部线程池， 即负责保持工作线程的集合， 在运行中管理线程的创建、销毁， 工作线程被抽象为静态内部类Worker
* ThreadFactory, 即负责创建线程

##### 线程池实践
* 避免任务堆积、避免过度扩展线程、避免死锁等
* 线程池大小选择
    * 主要进行计算任务，通常线程数=cpu核心数
    * 主要进行I/O任务，通常线程数 = CPU核数 × 目标CPU利用率 ×（1 + 平均等待时间/平均工作时间）
  
#### 并发工具类
##### 主要内容
* 提供了比 synchronized 更加高级的各种同步结构，包括 CountDownLatch、CyclicBarrier、Semaphore
    * CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同： CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；
    * 而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行； CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的；
    * Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限
* 各种线程安全的容器，比如最常见的 ConcurrentHashMap
* 各种并发队列实现，比如典型的 ArrayBlockingQueue
* Executor 框架，可以创建各种不同类型的线程池

 ### 安全
#### 注入攻击
攻击者将不可信的动态内容注入到程序中，从而产生与期望不一致的结果
* SQL注入，是最常见的注入攻击方式，往往是因为后端SQL语句是通过界面输入信息拼接而来，利用输入信息篡改SQL
    * 输入校验，限定合法输入内容
    * 利用PreparedStatement，而不是动态SQL
    * 限制数据库查询、修改等权限
* XML注入， 跟SQL注入类似，利用用户输入修改XML的数据格式或添加新的XML节点，导致解析XML异常
    * 输入正则校验
    * 输入转码处理
* 操作系统命令注入

#### 中间人攻击
攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制
#### Dos攻击
常见表现为利用大量机器发送请求，将目标网站的带宽和其他资源耗尽，导致无法正常响应合法用户的请求
#### 安全机制
##### 运行时安全机制
* 类加载过程中的字节码验证，以防止恶意代码或不符合规范代码影响运行
* 利用SecurityManger，限制代码的运行时行为能力， 例如限制对文件系统的操作权限

##### 安全框架API
* 加密解密API、授权鉴权API

##### JDK集成的安全工具
* keytool，管理密钥、证书等

## 工具
#### 辅助工具
* jlink:自定义jre /减少内存消耗/
* jdeps

#### 编译器
* javac
* sjavac

#### 诊断工具
* jmap
* jstack
* jconsole
* jcmd